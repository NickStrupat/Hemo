//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from HemoParser.g4 by ANTLR 4.7

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7")]
[System.CLSCompliant(false)]
public partial class HemoParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Utf8ByteOrderMark=1, EndOfFile=2, SingleLineDocComment=3, DelimitedDocComment=4, 
		SingleLineComment=5, DelimitedComment=6, NewLine=7, LineFeed=8, CarriageReturn=9, 
		CrLf=10, Space=11, Spaces=12, Tab=13, Sign=14, DecimalIntegerLiteral=15, 
		HexadecimalIntegerLiteral=16, OctalIntegerLiteral=17, BinaryIntegerLiteral=18, 
		DecimalRealLiteral=19, CharacterLiteral=20, DecimalNumeral=21, IntegerTypeSuffix=22, 
		HexPrefix=23, HexNumeral=24, OctalPrefix=25, OctalNumeral=26, BinaryPrefix=27, 
		BinaryNumeral=28, ZERO=29, ONE=30, U=31, I=32, HEXADECIMAL_PREFIX=33, 
		OCTAL_PREFIX=34, BINARY_PREFIX=35, StorageSize=36, Abstract=37, Alias=38, 
		As=39, Base=40, Break=41, Case=42, Catch=43, Checked=44, Class=45, Const=46, 
		Continue=47, Default=48, Delegate=49, Do=50, Else=51, Enum=52, Event=53, 
		Explicit=54, Extern=55, False=56, FieldOf=57, Finally=58, Fixed=59, Func=60, 
		For=61, ForEach=62, Goto=63, If=64, Implicit=65, In=66, Interface=67, 
		Internal=68, Is=69, Lock=70, Methodof=71, Nameof=72, Namespace=73, New=74, 
		Null=75, Operator=76, Out=77, Override=78, Params=79, Private=80, PropertyOf=81, 
		Protected=82, Public=83, Readonly=84, Ref=85, Return=86, Sealed=87, SizeOf=88, 
		StackAlloc=89, Static=90, Switch=91, This=92, Throw=93, True=94, Try=95, 
		TypeOf=96, Unchecked=97, Unsafe=98, Using=99, Virtual=100, Void=101, Volatile=102, 
		While=103, OpenBrace=104, OpenBracket=105, CloseBracket=106, OpenParens=107, 
		CloseParens=108, Dot=109, Comma=110, Colon=111, Semicolon=112, Plus=113, 
		Minus=114, Star=115, Div=116, Percent=117, Amp=118, BitwiseOr=119, Caret=120, 
		Bang=121, Tilde=122, Assignment=123, LT=124, GT=125, INTERR=126, DOUBLE_COLON=127, 
		OP_COALESCING=128, OP_INC=129, OP_DEC=130, OP_AND=131, OP_OR=132, OP_PTR=133, 
		OP_EQ=134, OP_NE=135, OP_LE=136, OP_GE=137, OP_ADD_ASSIGNMENT=138, OP_SUB_ASSIGNMENT=139, 
		OP_MULT_ASSIGNMENT=140, OP_DIV_ASSIGNMENT=141, OP_MOD_ASSIGNMENT=142, 
		OP_AND_ASSIGNMENT=143, OP_OR_ASSIGNMENT=144, OP_XOR_ASSIGNMENT=145, OP_LEFT_SHIFT=146, 
		OP_LEFT_SHIFT_ASSIGNMENT=147, IDENTIFIER=148;
	public const int
		RULE_compilationUnit = 0, RULE_literal = 1, RULE_nullLiteral = 2, RULE_booleanLiteral = 3, 
		RULE_integerLiteral = 4, RULE_decimalIntegerLiteral = 5, RULE_hexadecimalIntegerLiteral = 6, 
		RULE_octalIntegerLiteral = 7, RULE_binaryIntegerLiteral = 8, RULE_realLiteral = 9, 
		RULE_characterLiteral = 10;
	public static readonly string[] ruleNames = {
		"compilationUnit", "literal", "nullLiteral", "booleanLiteral", "integerLiteral", 
		"decimalIntegerLiteral", "hexadecimalIntegerLiteral", "octalIntegerLiteral", 
		"binaryIntegerLiteral", "realLiteral", "characterLiteral"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\u00EF\u00BB\u00BF'", null, null, null, null, null, null, "'\n'", 
		"'\r'", null, "'\u0020'", null, "'\t'", null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, "'0'", "'1'", 
		"'u'", "'i'", "'0x'", "'0o'", "'0b'", null, "'abstract'", "'alias'", "'as'", 
		"'base'", "'break'", "'case'", "'catch'", "'checked'", "'class'", "'const'", 
		"'continue'", "'default'", "'delegate'", "'do'", "'else'", "'enum'", "'event'", 
		"'explicit'", "'extern'", "'false'", "'fieldof'", "'finally'", "'fixed'", 
		"'func'", "'for'", "'foreach'", "'goto'", "'if'", "'implicit'", "'in'", 
		"'interface'", "'internal'", "'is'", "'lock'", "'methodof'", "'nameof'", 
		"'namespace'", "'new'", "'null'", "'operator'", "'out'", "'override'", 
		"'params'", "'private'", "'propertyof'", "'protected'", "'public'", "'readonly'", 
		"'ref'", "'return'", "'sealed'", "'sizeof'", "'stackalloc'", "'static'", 
		"'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'unchecked'", 
		"'unsafe'", "'using'", "'virtual'", "'void'", "'volatile'", "'while'", 
		"'{'", "'['", "']'", "'('", "')'", "'.'", "','", "':'", "';'", "'+'", 
		"'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'", "'!'", "'~'", "'='", 
		"'<'", "'>'", "'?'", "'::'", "'??'", "'++'", "'--'", "'&&'", "'||'", "'->'", 
		"'=='", "'!='", "'<='", "'>='", "'+='", "'-='", "'*='", "'/='", "'%='", 
		"'&='", "'|='", "'^='", "'<<'", "'<<='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Utf8ByteOrderMark", "EndOfFile", "SingleLineDocComment", "DelimitedDocComment", 
		"SingleLineComment", "DelimitedComment", "NewLine", "LineFeed", "CarriageReturn", 
		"CrLf", "Space", "Spaces", "Tab", "Sign", "DecimalIntegerLiteral", "HexadecimalIntegerLiteral", 
		"OctalIntegerLiteral", "BinaryIntegerLiteral", "DecimalRealLiteral", "CharacterLiteral", 
		"DecimalNumeral", "IntegerTypeSuffix", "HexPrefix", "HexNumeral", "OctalPrefix", 
		"OctalNumeral", "BinaryPrefix", "BinaryNumeral", "ZERO", "ONE", "U", "I", 
		"HEXADECIMAL_PREFIX", "OCTAL_PREFIX", "BINARY_PREFIX", "StorageSize", 
		"Abstract", "Alias", "As", "Base", "Break", "Case", "Catch", "Checked", 
		"Class", "Const", "Continue", "Default", "Delegate", "Do", "Else", "Enum", 
		"Event", "Explicit", "Extern", "False", "FieldOf", "Finally", "Fixed", 
		"Func", "For", "ForEach", "Goto", "If", "Implicit", "In", "Interface", 
		"Internal", "Is", "Lock", "Methodof", "Nameof", "Namespace", "New", "Null", 
		"Operator", "Out", "Override", "Params", "Private", "PropertyOf", "Protected", 
		"Public", "Readonly", "Ref", "Return", "Sealed", "SizeOf", "StackAlloc", 
		"Static", "Switch", "This", "Throw", "True", "Try", "TypeOf", "Unchecked", 
		"Unsafe", "Using", "Virtual", "Void", "Volatile", "While", "OpenBrace", 
		"OpenBracket", "CloseBracket", "OpenParens", "CloseParens", "Dot", "Comma", 
		"Colon", "Semicolon", "Plus", "Minus", "Star", "Div", "Percent", "Amp", 
		"BitwiseOr", "Caret", "Bang", "Tilde", "Assignment", "LT", "GT", "INTERR", 
		"DOUBLE_COLON", "OP_COALESCING", "OP_INC", "OP_DEC", "OP_AND", "OP_OR", 
		"OP_PTR", "OP_EQ", "OP_NE", "OP_LE", "OP_GE", "OP_ADD_ASSIGNMENT", "OP_SUB_ASSIGNMENT", 
		"OP_MULT_ASSIGNMENT", "OP_DIV_ASSIGNMENT", "OP_MOD_ASSIGNMENT", "OP_AND_ASSIGNMENT", 
		"OP_OR_ASSIGNMENT", "OP_XOR_ASSIGNMENT", "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", 
		"IDENTIFIER"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "HemoParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static HemoParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public HemoParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public HemoParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class CompilationUnitContext : ParserRuleContext {
		public ITerminalNode EndOfFile() { return GetToken(HemoParser.EndOfFile, 0); }
		public ITerminalNode Utf8ByteOrderMark() { return GetToken(HemoParser.Utf8ByteOrderMark, 0); }
		public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		public CompilationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilationUnit; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompilationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompilationUnitContext compilationUnit() {
		CompilationUnitContext _localctx = new CompilationUnitContext(Context, State);
		EnterRule(_localctx, 0, RULE_compilationUnit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 23;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Utf8ByteOrderMark) {
				{
				State = 22; Match(Utf8ByteOrderMark);
				}
			}

			State = 28;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DecimalIntegerLiteral) | (1L << HexadecimalIntegerLiteral) | (1L << OctalIntegerLiteral) | (1L << BinaryIntegerLiteral) | (1L << DecimalRealLiteral) | (1L << CharacterLiteral) | (1L << False))) != 0) || _la==Null || _la==True) {
				{
				{
				State = 25; literal();
				}
				}
				State = 30;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 31; Match(EndOfFile);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public NullLiteralContext nullLiteral() {
			return GetRuleContext<NullLiteralContext>(0);
		}
		public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		public IntegerLiteralContext integerLiteral() {
			return GetRuleContext<IntegerLiteralContext>(0);
		}
		public RealLiteralContext realLiteral() {
			return GetRuleContext<RealLiteralContext>(0);
		}
		public CharacterLiteralContext characterLiteral() {
			return GetRuleContext<CharacterLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 2, RULE_literal);
		try {
			State = 38;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Null:
				EnterOuterAlt(_localctx, 1);
				{
				State = 33; nullLiteral();
				}
				break;
			case False:
			case True:
				EnterOuterAlt(_localctx, 2);
				{
				State = 34; booleanLiteral();
				}
				break;
			case DecimalIntegerLiteral:
			case HexadecimalIntegerLiteral:
			case OctalIntegerLiteral:
			case BinaryIntegerLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 35; integerLiteral();
				}
				break;
			case DecimalRealLiteral:
				EnterOuterAlt(_localctx, 4);
				{
				State = 36; realLiteral();
				}
				break;
			case CharacterLiteral:
				EnterOuterAlt(_localctx, 5);
				{
				State = 37; characterLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullLiteralContext : ParserRuleContext {
		public ITerminalNode Null() { return GetToken(HemoParser.Null, 0); }
		public NullLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NullLiteralContext nullLiteral() {
		NullLiteralContext _localctx = new NullLiteralContext(Context, State);
		EnterRule(_localctx, 4, RULE_nullLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40; Match(Null);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		public ITerminalNode True() { return GetToken(HemoParser.True, 0); }
		public ITerminalNode False() { return GetToken(HemoParser.False, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 6, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 42;
			_la = TokenStream.LA(1);
			if ( !(_la==False || _la==True) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerLiteralContext : ParserRuleContext {
		public DecimalIntegerLiteralContext decimalIntegerLiteral() {
			return GetRuleContext<DecimalIntegerLiteralContext>(0);
		}
		public HexadecimalIntegerLiteralContext hexadecimalIntegerLiteral() {
			return GetRuleContext<HexadecimalIntegerLiteralContext>(0);
		}
		public OctalIntegerLiteralContext octalIntegerLiteral() {
			return GetRuleContext<OctalIntegerLiteralContext>(0);
		}
		public BinaryIntegerLiteralContext binaryIntegerLiteral() {
			return GetRuleContext<BinaryIntegerLiteralContext>(0);
		}
		public IntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integerLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntegerLiteralContext integerLiteral() {
		IntegerLiteralContext _localctx = new IntegerLiteralContext(Context, State);
		EnterRule(_localctx, 8, RULE_integerLiteral);
		try {
			State = 48;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DecimalIntegerLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 44; decimalIntegerLiteral();
				}
				break;
			case HexadecimalIntegerLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 45; hexadecimalIntegerLiteral();
				}
				break;
			case OctalIntegerLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 46; octalIntegerLiteral();
				}
				break;
			case BinaryIntegerLiteral:
				EnterOuterAlt(_localctx, 4);
				{
				State = 47; binaryIntegerLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalIntegerLiteralContext : ParserRuleContext {
		public ITerminalNode DecimalIntegerLiteral() { return GetToken(HemoParser.DecimalIntegerLiteral, 0); }
		public DecimalIntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalIntegerLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimalIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DecimalIntegerLiteralContext decimalIntegerLiteral() {
		DecimalIntegerLiteralContext _localctx = new DecimalIntegerLiteralContext(Context, State);
		EnterRule(_localctx, 10, RULE_decimalIntegerLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; Match(DecimalIntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HexadecimalIntegerLiteralContext : ParserRuleContext {
		public ITerminalNode HexadecimalIntegerLiteral() { return GetToken(HemoParser.HexadecimalIntegerLiteral, 0); }
		public HexadecimalIntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hexadecimalIntegerLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHexadecimalIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HexadecimalIntegerLiteralContext hexadecimalIntegerLiteral() {
		HexadecimalIntegerLiteralContext _localctx = new HexadecimalIntegerLiteralContext(Context, State);
		EnterRule(_localctx, 12, RULE_hexadecimalIntegerLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 52; Match(HexadecimalIntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OctalIntegerLiteralContext : ParserRuleContext {
		public ITerminalNode OctalIntegerLiteral() { return GetToken(HemoParser.OctalIntegerLiteral, 0); }
		public OctalIntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_octalIntegerLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctalIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OctalIntegerLiteralContext octalIntegerLiteral() {
		OctalIntegerLiteralContext _localctx = new OctalIntegerLiteralContext(Context, State);
		EnterRule(_localctx, 14, RULE_octalIntegerLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54; Match(OctalIntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryIntegerLiteralContext : ParserRuleContext {
		public ITerminalNode BinaryIntegerLiteral() { return GetToken(HemoParser.BinaryIntegerLiteral, 0); }
		public BinaryIntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryIntegerLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BinaryIntegerLiteralContext binaryIntegerLiteral() {
		BinaryIntegerLiteralContext _localctx = new BinaryIntegerLiteralContext(Context, State);
		EnterRule(_localctx, 16, RULE_binaryIntegerLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 56; Match(BinaryIntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RealLiteralContext : ParserRuleContext {
		public ITerminalNode DecimalRealLiteral() { return GetToken(HemoParser.DecimalRealLiteral, 0); }
		public RealLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_realLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRealLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RealLiteralContext realLiteral() {
		RealLiteralContext _localctx = new RealLiteralContext(Context, State);
		EnterRule(_localctx, 18, RULE_realLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; Match(DecimalRealLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharacterLiteralContext : ParserRuleContext {
		public ITerminalNode CharacterLiteral() { return GetToken(HemoParser.CharacterLiteral, 0); }
		public CharacterLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_characterLiteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IHemoParserVisitor<TResult> typedVisitor = visitor as IHemoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacterLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CharacterLiteralContext characterLiteral() {
		CharacterLiteralContext _localctx = new CharacterLiteralContext(Context, State);
		EnterRule(_localctx, 20, RULE_characterLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 60; Match(CharacterLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x96', '\x41', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x3', '\x2', '\x5', '\x2', '\x1A', '\n', '\x2', 
		'\x3', '\x2', '\a', '\x2', '\x1D', '\n', '\x2', '\f', '\x2', '\xE', '\x2', 
		' ', '\v', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3', ')', '\n', '\x3', 
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\x3', '\x5', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x5', '\x6', '\x33', '\n', 
		'\x6', '\x3', '\a', '\x3', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\t', 
		'\x3', '\t', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', '\x3', 
		'\f', '\x3', '\f', '\x3', '\f', '\x2', '\x2', '\r', '\x2', '\x4', '\x6', 
		'\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x2', '\x3', 
		'\x4', '\x2', ':', ':', '`', '`', '\x2', '>', '\x2', '\x19', '\x3', '\x2', 
		'\x2', '\x2', '\x4', '(', '\x3', '\x2', '\x2', '\x2', '\x6', '*', '\x3', 
		'\x2', '\x2', '\x2', '\b', ',', '\x3', '\x2', '\x2', '\x2', '\n', '\x32', 
		'\x3', '\x2', '\x2', '\x2', '\f', '\x34', '\x3', '\x2', '\x2', '\x2', 
		'\xE', '\x36', '\x3', '\x2', '\x2', '\x2', '\x10', '\x38', '\x3', '\x2', 
		'\x2', '\x2', '\x12', ':', '\x3', '\x2', '\x2', '\x2', '\x14', '<', '\x3', 
		'\x2', '\x2', '\x2', '\x16', '>', '\x3', '\x2', '\x2', '\x2', '\x18', 
		'\x1A', '\a', '\x3', '\x2', '\x2', '\x19', '\x18', '\x3', '\x2', '\x2', 
		'\x2', '\x19', '\x1A', '\x3', '\x2', '\x2', '\x2', '\x1A', '\x1E', '\x3', 
		'\x2', '\x2', '\x2', '\x1B', '\x1D', '\x5', '\x4', '\x3', '\x2', '\x1C', 
		'\x1B', '\x3', '\x2', '\x2', '\x2', '\x1D', ' ', '\x3', '\x2', '\x2', 
		'\x2', '\x1E', '\x1C', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x1F', '\x3', 
		'\x2', '\x2', '\x2', '\x1F', '!', '\x3', '\x2', '\x2', '\x2', ' ', '\x1E', 
		'\x3', '\x2', '\x2', '\x2', '!', '\"', '\a', '\x4', '\x2', '\x2', '\"', 
		'\x3', '\x3', '\x2', '\x2', '\x2', '#', ')', '\x5', '\x6', '\x4', '\x2', 
		'$', ')', '\x5', '\b', '\x5', '\x2', '%', ')', '\x5', '\n', '\x6', '\x2', 
		'&', ')', '\x5', '\x14', '\v', '\x2', '\'', ')', '\x5', '\x16', '\f', 
		'\x2', '(', '#', '\x3', '\x2', '\x2', '\x2', '(', '$', '\x3', '\x2', '\x2', 
		'\x2', '(', '%', '\x3', '\x2', '\x2', '\x2', '(', '&', '\x3', '\x2', '\x2', 
		'\x2', '(', '\'', '\x3', '\x2', '\x2', '\x2', ')', '\x5', '\x3', '\x2', 
		'\x2', '\x2', '*', '+', '\a', 'M', '\x2', '\x2', '+', '\a', '\x3', '\x2', 
		'\x2', '\x2', ',', '-', '\t', '\x2', '\x2', '\x2', '-', '\t', '\x3', '\x2', 
		'\x2', '\x2', '.', '\x33', '\x5', '\f', '\a', '\x2', '/', '\x33', '\x5', 
		'\xE', '\b', '\x2', '\x30', '\x33', '\x5', '\x10', '\t', '\x2', '\x31', 
		'\x33', '\x5', '\x12', '\n', '\x2', '\x32', '.', '\x3', '\x2', '\x2', 
		'\x2', '\x32', '/', '\x3', '\x2', '\x2', '\x2', '\x32', '\x30', '\x3', 
		'\x2', '\x2', '\x2', '\x32', '\x31', '\x3', '\x2', '\x2', '\x2', '\x33', 
		'\v', '\x3', '\x2', '\x2', '\x2', '\x34', '\x35', '\a', '\x11', '\x2', 
		'\x2', '\x35', '\r', '\x3', '\x2', '\x2', '\x2', '\x36', '\x37', '\a', 
		'\x12', '\x2', '\x2', '\x37', '\xF', '\x3', '\x2', '\x2', '\x2', '\x38', 
		'\x39', '\a', '\x13', '\x2', '\x2', '\x39', '\x11', '\x3', '\x2', '\x2', 
		'\x2', ':', ';', '\a', '\x14', '\x2', '\x2', ';', '\x13', '\x3', '\x2', 
		'\x2', '\x2', '<', '=', '\a', '\x15', '\x2', '\x2', '=', '\x15', '\x3', 
		'\x2', '\x2', '\x2', '>', '?', '\a', '\x16', '\x2', '\x2', '?', '\x17', 
		'\x3', '\x2', '\x2', '\x2', '\x6', '\x19', '\x1E', '(', '\x32',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
